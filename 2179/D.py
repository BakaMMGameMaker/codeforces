t = int(input())
for _ in range(t):
    n = int(input())
    # s(p) = sigma i=0 to i=(2^n)-1 popcount(p0&...&pi)
    # popcount = bin(n)[2:].count('1')
    # 可以知道，一旦某一位变成了 0，那么在后续 & 中，它也只能是 0
    # 显然，我们要让 '1' 更多的数字排在前面，因为这样才能带来更大的初始 pop count
    # 需要注意，大的数字的排在前面可能会让数字归零
    # 毫无疑问，(2^n - 1) 肯定要排在第一个位置，因为他位数最多，且没有 '0'
    # 显然，为了让 sp 最大，在后续挑选数字的时候，每一位都要尽量少的引入新的 0
    # 挑选第二个数字时，我们注意到，如果第二个数字有且仅有一位为 0，那么其
    # 带来的损失就是剩下的所有数字中，此位置上位 1 的个数，显然我们想要让损失越小越好
    # 如果我们让最低位变成了 0，那么会带来约 n//2 的损失，如果是第二位，则损失约为 n//4
    # 显然，我们要让最高位变成 0，这个数字就是 2^(n-1)-1
    # 以此类推，为了让前面产生损失的速度尽量慢，最优的办法就是先放 2^(n)-1，然后
    # 从小到大排列低 n - 1 位置为 1 的数字，从小到大排列低 n - 2 位置为 1 的数字，...
    # 从小到大排列所有低 1 位置为 1 的数字（奇数）
    # 注意，在这之前，我们排列的所有数字都不是偶数，因此剩下的数字一定是偶数
    # 只需要把剩下的偶数从零开始从小到大排列即可
    print(2**n - 1, end=" ")
    for k in range(n - 1, 0, -1):
        # 处理低 k 位为 '1' 的所有元素
        # 注意，第 k + 1 位一定是 '0'，否则就变成了低 k + 1 位都是 '1' 了
        # 这一部分含有的数字个数为 2^m，其中 m 为可以是 1 的位数
        # 也即 n - k - 1
        mask = (1 << k) - 1
        m = n - k - 1
        cur = 0
        for i in range(2**m):
            print((cur << (k + 1)) | mask, end=" ")
            cur += 1
    for i in range(0, 2**n - 1, 2):
        print(i, end=" ")
